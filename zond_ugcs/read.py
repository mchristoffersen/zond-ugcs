import struct
from datetime import datetime
import logging
import pyproj
import sys
import matplotlib.pyplot as plt

from zond_ugcs import log

import numpy as np
import pandas as pd


def ddm2dd(ddm):
    dd = int(ddm / 100)
    dd += (ddm - dd * 100) / 60
    return dd


def read(file, loglevel="CRITICAL"):
    log.setLevel(loglevel)
    log.info("Beginning Zond Aero 500 file read")

    if type(file) != str:
        log.critical("Data file name is not a string")
        return

    try:
        log.info("Opening data file: %s", file)
        fd = open(file, "rb")
    except Exception as e:
        log.critical("Failed to open data file")
        log.critical(e)
        return

    log.info("Opened data file")

    if fd.read(42) != b"This SEG-Y file has been generated by UgCS":
        log.error("Data file does not appear to be Zond Aero 500 SEG-Y file")

    # Seek to end of file to get size, then return to beginning
    size = fd.seek(0, 2)
    fd.seek(0, 0)
    log.info("Data file size: %d bytes" % size)

    # Read SEG-Y file headers
    log.info("Reading text header")
    tHead = fd.read(3200)  # SEG-Y text header

    log.info("Reading binary header")
    bHead = fd.read(400)  # SEG-Y binary header

    ntrace = int(
        (size - fd.tell()) / (240 + 512 * 2)
    )  # 240 + 512*2 is header+trace size
    if ntrace != (size - fd.tell()) / (240 + 512 * 2):
        log.warning(
            "Non-integer number of traces calculated: %.3f"
            % ((size - fd.tell()) / (240 + 512 * 2))
        )
    else:
        log.info("Data file contains %d traces" % ntrace)

    # Read info from binary header
    dt = struct.unpack("h", bHead[16:18])[0] * 1e-12
    log.info("Sample interval: %d picoseconds" % (dt * 1e12))

    # Read data from SEG-Y traces and trace headers
    bscan = np.zeros((512, ntrace), dtype=np.int16)
    lon = np.zeros((ntrace), dtype=np.float64)
    lat = np.zeros((ntrace), dtype=np.float64)
    agl = np.zeros((ntrace), dtype=np.float32)
    time = np.empty((ntrace), dtype=datetime)

    log.info("Reading traces")
    try:
        for i in range(ntrace):
            header = fd.read(240)

            # Position
            agl[i] = struct.unpack("<f", header[40:44])[0]
            lon[i] = ddm2dd(struct.unpack("<d", header[182:190])[0])
            lat[i] = ddm2dd(struct.unpack("<d", header[190:198])[0])

            # Time
            year = struct.unpack("h", header[156:158])[0]
            doy = struct.unpack("h", header[158:160])[0]
            hour = struct.unpack("h", header[160:162])[0]
            minute = struct.unpack("h", header[162:164])[0]
            second = struct.unpack("h", header[164:166])[0]
            msecond = struct.unpack("h", header[168:170])[0]
            timestr = "%d %d %d %d %d %d" % (year, doy, hour, minute, second, msecond)
            time[i] = datetime.strptime(timestr, "%Y %j %H %M %S %f")

            # Trace
            bscan[:, i] = struct.unpack("h" * 512, fd.read(1024))
    except Exception as e:
        log.critical("Failed to read traces")
        log.critical(e)
        return

    fd.close()
    log.info("Data file read successfully")

    # Get RTK and altimeter info
    try:
        pfile = file.replace("gpr.sgy", "position.csv")
        log.info("Opening position file: %s" % pfile)
        df = pd.read_csv(pfile)
    except Exception as e:
        log.critical("Failed to open position file")
        log.critical(e)
        return

    log.info("Decimating position file to integer trace indices")
    df = df[np.logical_not(np.isnan(df["GPR:Trace"]))]
    df = df[df["GPR:Trace"] == df["GPR:Trace"].astype(np.int32)]
    df["GPR:Trace"] = df["GPR:Trace"].astype(np.int32)
    rtkONMask = df["RTK Status"] == "ON"

    log.info(
        "%d%% of traces have RTK fix"
        % (100 * np.sum(df["RTK Status"] == "ON") // ntrace)
    )

    if len(df) != ntrace:
        log.warning("Length of decimated position file != number of traces")

    hgt = np.zeros(ntrace, dtype=np.float32)
    speed = np.zeros(ntrace, dtype=np.float32) * np.nan
    rtkMask = np.zeros(ntrace, dtype=bool)
    aglMask = np.zeros(ntrace, dtype=bool)
    speedMask = np.zeros(ntrace, dtype=bool)

    log.info("Extracting RTK position, altimeter height, UAS speed")
    rtkMask[df["GPR:Trace"]] = rtkONMask
    aglMask[df["GPR:Trace"]] = True
    speedMask[df["GPR:Trace"]] = True

    lon[rtkMask] = df["Longitude RTK"][rtkONMask]
    lat[rtkMask] = df["Latitude RTK"][rtkONMask]
    hgt[rtkMask] = df["Altitude RTK"][rtkONMask]
    agl[aglMask] = df["ALT:Altitude"]
    speed[speedMask] = df["Velocity"]

    log.info("Calculating ECEF UAS location")
    # lat/lon/hgt -> ECEF
    xform = pyproj.Transformer.from_crs(4326, 4978)
    x, y, z = xform.transform(lat, lon, hgt)

    log.info("Calculating along-flightline distance")
    dx = np.diff(x)
    dy = np.diff(y)
    dz = np.diff(z)
    dDist = np.sqrt(dx ** 2 + dy ** 2 + dz ** 2)
    dist = np.concatenate(([0], np.cumsum(dDist)))

    dataDict = {
        "bscan": bscan,  # The BScan or radargram, data acquired by the GPR (size: mxn)
        "lon": lon,  # Longitude of the UAS (WGS84) (size: n)
        "lat": lat,  # Latitude of the UAS (WGS84) (size: n)
        "hgt": hgt,  # Height of the UAS about the WGS84 ellipsoid (size: n)
        "agl": agl,  # Height of the UAS above ground (size: n)
        "speed": speed,  # Speed of the UAS (m/s) (size: n)
        "rtkMask": rtkMask,  # Mask for lon, lat, and hgt fields denoting which entries come from RTK (True == RTK) (size: n)
        "altMask": aglMask,  # Mask for agl field denoting which entries come from laser altimeter (True == altimeter) (size: n)
        "speedMask": speedMask,  # Mask for speed field denoting which entries are not nan (True == not nan) (size: n)
        "time": time,  # Time of the acquisition of each trace (size: n)
        "dt": dt,  # Fast time sampling interval of the GPR (size: 1)
    }

    log.info("Zond Aero 500 file read complete")
    return dataDict
